# Nutexb Swizzling
<img src="https://raw.githubusercontent.com/ScanMountGoat/nutexb_swizzle/main/swizzle3d.png" height="auto" width="100%">

Documentation and tools for Tegra X1 swizzling used for nutexb texture files for Smash Ultimate.  The swizzle code and bit pattern technique is based on the following [blog post](https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/). The above image shows a swizzled RGBA 3D lut. The different colored blocks correspond to a 4x2 grid of GOBs ("groups of bytes" from the Tegra TRM). GOBs are 64x8 bytes (512 total bytes), which in this case is 16x8 pixels. The properly deswizzled version can be found on the [Smush-Lut repo](https://github.com/ScanMountGoat/Smush-LUT).

## Documentation
See the [swizzle](swizzle.md) page for documentation on what formats and dimensions are currently supported as well as an explanation of texture swizzling. 

## nutexb_swizzle
The program can automatically generate lookup tables for swizzling and deswizzling texture data based on a pair of swizzled and unswizzled image data files. For the power of two case, the lookup table can be efficiently expressed as bit patterns for the x, y, and z components of the pixel address. 

The generated values for the "swizzled" input are unique for each unit of image data. For uncompressed RGBA data, unique values are generated per pixel. For compressed data, unique values are generated for each 4x4 pixel tile. The generated input values are the pixel or tile's linear address (width * y + x), but the program only assumes that all pixel or tile values are unique. The lookup table is computed by finding the new location of each input pixel or tile in the deswizzled output file.  This is handled automatically by correctly specifying the width, height, and format.

### Generating Test Data
*nutexb_swizzle will attempt to use all available cores for performance reasons. This will result in very high CPU usage, especially for textures larger than 1024x1024.*    
1. Write unique block values to the Nutexb. Pad the image size with `--blockcount` as needed.  
`cargo run --release -- write_addresses -w 512 -h 512 -f bc7 -o "def_mario_001_col.nutexb" --blockcount 43872` 
2. Write the unique block values to a binary file. Pad the image size with `--blockcount` as needed.  
`cargo run --release -- write_addresses -w 512 -h 512 -f bc7 -o "linear.bin" --blockcount 43872`
3. Calculate the deswizzled version of `linear.bin` using an emulator or reference swizzle/deswizzle implementation. Save the resulting blocks to `deswizzle.bin`. The provided test data is generated by dumping the raw OpenGL texture data from the base mip level using [RenderDoc](https://renderdoc.org/) and [yuzu emulator](https://yuzu-emu.org/) (tested on version 500). The emulator deswizzles the texture data, which allows for computing a lookup table and guessing the swizzle patterns. 
4. For power of two textures, guess the swizzle pattern based on a pair of swizzed and deswizzled input data.    

Calculate patterns for a single mip level.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear.bin" --deswizzled "deswizzle.bin"`  

Specify a DDS with mipmaps for the deswizzled output. The swizzled input data should contain all mipmaps.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear_all_mips.bin" --deswizzled "deswizzled.dds"`

Specify a DDS with mipmaps for for both inputs to match mip levels individually.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear.dds" --deswizzled "deswizzled.dds"`
