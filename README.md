# Tegra X1 Swizzling
<img src="https://raw.githubusercontent.com/ScanMountGoat/nutexb_swizzle/main/swizzle3d.png" height="auto" width="100%">
<img src="https://raw.githubusercontent.com/ScanMountGoat/nutexb_swizzle/main/deswizzled3d.png" height="auto" width="100%">

Documentation and tools for the Tegra X1 block linear swizzling algorithm used for the Nintendo Switch.

The above image shows a swizzled RGBA 16x16x16 pixel 3D lut. The different colored blocks correspond to a 16x2 grid of GOBs ("groups of bytes" from the Tegra TRM). GOBs are 64x8 bytes (512 total bytes), which in this case is 16x8 pixels. The deswizzled version is shown below.

## Swizzling
Texture are often stored in a swizzled layout to make texture accesses more cache friendly. The standard linear or row-major memory ordering is only cache friendly when the data is accessed in row-major order. This is rarely the case for image textures for models, so the bytes of a surface are rearranged to improve the number of cache misses using a process known as "swizzling". 

It's important to note that swizzling affects memory addressing, so surfaces should be thought of as 2D or 3D arrays of bytes rather than pixels or 4x4 pixel blocks. The swizzling algorithm is agnostic to whether the data is RGBA8 or BC7 compressed. The format is used only for converting the surface dimensions from pixels to bytes. This avoids making assumptions about relationships between the size of a pixel or compressed block and the swizzling algorithm and results in more efficient code. The byte dimensions of swizzled surfaces are rounded up to integral dimensions in GOBs (64x8) bytes. The surface dimensions in pixels do not need to be powers of two for swizzling to work correctly.

## tegra_swizzle 
[![Latest Version](https://img.shields.io/crates/v/tegra_swizzle.svg)](https://crates.io/crates/tegra_swizzle) [![docs.rs](https://docs.rs/tegra_swizzle/badge.svg)](https://docs.rs/tegra_swizzle)

A safe and efficient pure Rust implementation of swizzling and deswizzling for the block linear format. 

### C FFI 
For using the library in other languages through C FFI, first build the library with `cargo build --release --features=ffi`. This requires the Rust toolchain to be installed.  

The generated `tegra_swizzle.dll` or `tegra_swizzle.so` depending on the platform can be used the same way as any other compiled C library. See the ffi module in the docs.rs link for documentation.

## Test Data
This repository contains [sample data](https://github.com/ScanMountGoat/nutexb_swizzle/tree/main/swizzle_data) for testing swizzling and deswizzling. These files were generated using the swizzling implementation for the Yuzu emulator due to difficulties in testing on actual hardware. For additional tests used by tegra_swizzle, see the source code and fuzz directories.   

## Documentation
See the [swizzle](swizzle.md) page for a more formal description of swizzling. While not rigorous enough to be considered a proof, this helps motivate some of the techniques and optimizations applied to this library. The following [swizzling blog post](https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/) also provides some additional insights into swizzling. 
Note that the technique used in this implementation differs from those described in the post.  

## nutexb_swizzle
The program can automatically generate lookup tables for swizzling and deswizzling texture data based on a pair of swizzled and unswizzled image data files. For the power of two case, the lookup table can be efficiently expressed as bit patterns for the x, y, and z components of the pixel address. The bit pattern technique is based on the following [blog post](https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/).  

The generated values for the "swizzled" input are unique for each unit of image data. For uncompressed RGBA data, unique values are generated per pixel. For compressed data, unique values are generated for each 4x4 pixel tile. The generated input values are the pixel or tile's linear address (width * y + x), but the program only assumes that all pixel or tile values are unique. The lookup table is computed by finding the new location of each input pixel or tile in the deswizzled output file.  This is handled automatically by correctly specifying the width, height, and format.

### Generating Test Data
1. Write unique values to the Nutexb. Pad the image size with `--imagesize` as needed.  
`cargo run --release -- write_addresses -w 512 -h 512 -f bc7 -o "def_mario_001_col.nutexb" --imagesize 262144` 
2. Write the unique values to a binary file. Pad the image size with `--imagesize` as needed.  
`cargo run --release -- write_addresses -w 512 -h 512 -f bc7 -o "linear.bin" --imagesize 262144`
3. Calculate the deswizzled version of `linear.bin` using an emulator or reference swizzle/deswizzle implementation. Save the resulting data to `deswizzle.bin`. The provided test data is generated by dumping the raw texture data from the base mip level using [RenderDoc](https://renderdoc.org/) and [Ryjinx](https://ryujinx.org/) or [yuzu emulator](https://yuzu-emu.org/) (tested on version 499). The emulator deswizzles the texture data, which allows for computing a lookup table and guessing the swizzle patterns. For exporting the raw image data from RenderDoc, see [viewing a texture as a buffer](https://renderdoc.org/docs/window/texture_viewer.html#view-texture-as-buffer).
4. For power of two textures, guess the swizzle pattern based on a pair of swizzed and deswizzled input data. For non power of two textures or for textures where the swizzle patterns overlap, it's best to instead generate a lookup table using the `write_swizzle_lut` subcommand.

Calculate patterns for a single mip level.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear.bin" --deswizzled "deswizzle.bin"`  

Specify a DDS with mipmaps for the deswizzled output. The swizzled input data should contain all mipmaps.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear_all_mips.bin" --deswizzled "deswizzled.dds"`

Specify a DDS with mipmaps for for both inputs to match mip levels individually.  
`cargo run --release -- calculate_swizzle -w 512 -h 512 -f bc7 --swizzled "linear.dds" --deswizzled "deswizzled.dds"`
